# OrcheTeam 开发者手册

## 概念

### 智能体
从实现角度看, 智能体包括
 - ***配置*** 可以理解为实例化一个智能体不变的部分.如邮件发送, 发送邮件的协议,服务器,发送账号,密码是配置.因为在每次发送邮件时都提供前面的信息是没有意义的.
 - ***参数*** 调用一次智能体提供的信息.如邮件发送,邮件标题,内容,附件,接收方邮件地址. 参数和配置有时候并没有特别清晰的界限,如接收方邮件地址也可以作为配置,说明每次邮件发送给固定的地址.当前实现是接收方邮件地址既作为配置,也作为可选参数.当参数提供了,使用参数里的,否则使用配置里的.
- ***实现逻辑*** 通过代码实现处理逻辑

### 智能体分类
简单看,可以分为工具类和编排类. 
- ***工具类*** 提供单一的功能,无需借助其他智能体. 如邮件发送.
- ***编排类*** 有合作智能体,调用其他智能体实现流程编排,状态管理功能.

二者本质上无严格界限,如网页搜索智能体,既可以是工具类(当前实现);也可以是编排类(当前未实现),通过调用关键字生成,网页下载,网页汇总等工具智能体.

明确的是每个智能体都有自己独立的上下文.

## 智能体开发
### 流程
通过下面步骤开发智能体,打包成jar包.

参考用户手册部署章节部署.

建议在sampleAgent的基础上开发新的智能体.

### 特别说明
本项目还未固化,因此智能体开发相关接口,辅助函数都可能变化

后续描述相对简单,等时间充裕再补充.用户可参考智能体实现源代码.

### 界面标记
本项目通过java annotation定义了一套界面描述语言,支持输入框,选择框,时间选择框,表格等控件.

### 智能体类
智能体需要实现接口 com.mttk.orche.addon.agent.Agent,建议实现抽象类com.mttk.orche.addon.agent.impl.AbstractAgent  
AgentTemplateFlag的key参数给智能体一个独一无二的名称,系统级别的使用下划线(_)开头,自定义智能体建议不使用下划线开头.

### 配置界面
在智能体类上通过界面标记定义

### 参数界面
在AgentTemplateFlag上通过callDefineClass指向一个类,在此类上通过界面标记定义调用参数  
没有定义时使用缺省的调用参数,query(String)+_files(文件列表)

### 代码实现

下面的参数提供了智能体开发者和运行平台交互.AbstractAgent可以通过AgentParam得到

| 属性名 | 类型 | 说明 |
|--------|------|------|
| `context` | `AgentContext` | 智能体上下文 |
| `agentConfig` | `AdapterConfig` | 智能体的完整配置，包含智能体的所有设置 |
| `config` | `AdapterConfig` | 智能体配置中的 config 部分，从 `agentConfig` 中提取 |
| `requestRaw` | `String` | 原始请求的 JSON 字符串 |
| `request` | `AdapterConfig` | 解析后的请求对象，从 `requestRaw` 解析得到 |
| `toolName` | `String` | 工具名称，当前忽略,适用于一个智能体类里多个功能的场景 |

具体实现参考现有源代码,以后补充

### 打包
有两种打包方式
- **简单模式**,把实现类等class打包成jar,然后和引用的第三方jar拷贝到lib_user/addon里.此方式缺点是第三方jar包很容易和其他智能体版本冲突.
- **私有化第三方Jar包** 把实现类等class和引用的第三方Jar包打包在一个jar里面,然后拷贝到lib_user/addon里. 参考basicAgent的pom.xml的prepare-package阶段,注意修改 includeArtifactIds


## 下一步开发方向
### 互动式执行
用户能够停止任务执行并修改任务执行过程,如对于大模型规划的执行计划进行调整  
流程执行过程中允许用户参与, 如执行发邮件任务时没有合适的接收方电子邮件,提醒用户输入  
在已经执行完成的任务基础上执行新任务, 如利用执行完成任务结果补充新思路执行
### 任务恢复运行
失败的任务,中断的任务能够恢复运行,如 流程执行过程中Orche Team停止,启动Orche Team后任务自动继续.
### 集群支持
多服务器水平扩展  
服务器失效时任务切换  
### 实现更多的内置智能体
当前仅仅完成技术验证,针对不同场景需要开发不同的智能体.  
一个可行的方案是集成其他平台的优秀功能,如RAG功能,类似当前MCP实现,把其他平台功能封装成智能体.  
编排智能体当前仅仅实现了ReAct智能体.其缺点也很明显,令牌占用很多,不适合循环次数非常大的场景.通过在智能体内部记录和监视任务清单的方式可以避免,此类智能体会陆续发布.

### 界面扩展
当前通过annotation方式实现了初步的动态界面.  
后续会支持动态加载外部JS/CSS实现更为复杂的界面实现,如集成外部的BI实现数据的多维度展示.

### 多智能体
当前一个智能体类只能包含一个工具.以后会支持一个智能体类包含多个工具,类似一个MCP包含多个工具一样.

### 权限控制
功能权限和数据权限
### 其他
还有很多在开发列表里! :(

